// ============================================
// PLAYGROUND DATABASE SCHEMA (Prisma)
// ============================================

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

generator client {
    provider = "prisma-client-js"
}

// ============================================
// ENUMS
// ============================================

enum UserRole {
    USER
    ADMIN
    DEV
}

enum ResumeState {
    NOT_ANALYZED
    IN_PROGRESS
    ANALYZED
    FAILED
    REJECTED
}

enum Qualification {
    UNDER_QUALIFIED
    QUALIFIED
    OVERQUALIFIED
}

// ============================================
// MODELS
// ============================================

// USERS: Soft delete enabled via `deletedAt`
model User {
    id           String    @id @default(uuid())
    email        String    @unique
    password     String
    firstName    String?
    middleName   String?
    lastName     String?
    organization String?
    accessReason String?
    accessStatus Boolean   @default(true)
    role         UserRole  @default(USER)
    createdAt    DateTime  @default(now())
    updatedAt    DateTime  @updatedAt
    deletedAt    DateTime? // NULL = active

    // Relations
    Logs          Log[]
    RefreshTokens RefreshToken[]
    Limits        UserLimits?
    Archives      ResumeArchive[]
    JobListing    JobListing[]
    Policy        Policy[]
    Instruction   Instruction[]
}

model Log {
    id        String  @id @default(uuid())
    userId    String
    action    String // e.g. "CREATE_TASK", "UPDATE_PROJECT", "DELETE_COMMENT"
    entity    String // Entity type (e.g. "Task", "Project", "Comment")
    entityId  String // ID of the affected entity
    message   String? @db.Text // Optional descriptive message
    userAgent String? // Browser/device info
    metadata  Json? // Flexible field to store extra contextual data
    tag       String? // Optional: custom label (e.g., "security", "system")

    createdAt DateTime @default(now())

    user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model RefreshToken {
    id        String   @id @default(uuid())
    userId    String
    token     String   @unique
    createdAt DateTime @default(now())

    user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// USER LIMITS: Per-user custom trial limits
model UserLimits {
    id                   String   @id @default(uuid())
    userId               String   @unique
    maxArchives          Int      @default(5)
    maxResumesPerArchive Int      @default(100)
    maxPolicies          Int      @default(10)
    maxJobListings       Int      @default(10)
    maxInstructions      Int      @default(10)
    createdAt            DateTime @default(now())
    updatedAt            DateTime @updatedAt

    user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// Resume ARCHIVES: Collection of Resumes per user
model ResumeArchive {
    id          String   @id @default(uuid())
    userId      String
    name        String
    description String?
    createdAt   DateTime @default(now())
    updatedAt   DateTime @updatedAt

    user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)
    Resumes Resume[]
}

// ResumeS: Individual Resumes analyzed by AI
model Resume {
    id            String         @id @default(uuid())
    archiveId     String
    fileUrl       String
    state         ResumeState    @default(NOT_ANALYZED)
    candidateName String?
    qualification Qualification?
    score         Int?           @db.Integer
    reasoning     String?
    ai_model      String?
    createdAt     DateTime       @default(now())
    updatedAt     DateTime       @updatedAt

    archive ResumeArchive @relation(fields: [archiveId], references: [id], onDelete: Cascade)
}

model JobListing {
    id          String   @id @default(uuid())
    userId      String
    position    String
    department  String?
    description String
    createdAt   DateTime @default(now())
    updatedAt   DateTime @updatedAt

    user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Policy {
    id        String   @id @default(uuid())
    userId    String
    name      String
    content   String
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Instruction {
    id        String   @id @default(uuid())
    name      String
    userId    String
    content   String
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}
